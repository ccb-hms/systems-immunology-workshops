[
  {
    "objectID": "session3/pSet3.html#instructions",
    "href": "session3/pSet3.html#instructions",
    "title": "20  Problem Set 3",
    "section": "20.1 Instructions",
    "text": "20.1 Instructions\nIn this problem set, you will be going through an analysis resolve a potential label swap in phosphoproteomic mass spec data.\nIt is recommended to create a Quarto notebook for your report. You can create a new notebook in RSTudio by going to file->new file->quarto document. Set the default output to be a PDF. As an example, the entire workbook is a quarto document. More information can be found here. However, if you are finding it difficult to render your document, feel free to instead submit a script and separate writeup document."
  },
  {
    "objectID": "session3/pSet3.html#data-description",
    "href": "session3/pSet3.html#data-description",
    "title": "20  Problem Set 3",
    "section": "20.2 Data Description",
    "text": "20.2 Data Description\nWe are collaborating with a lab that is studying phosphorylation changes during covid infection. This dataset consists of phosphoproteomic TMT mass spec data from 2 10-plexes. We took samples at 0, 5, and 60 minutes post-infection. We also wanted to explore the specific role of 2 genes thought to be used in covid infection, RAB7A and NPC1. To do this, we included cell lines with each of these genes knocked out.\nWe wanted to have 2 replicates for each condition we were looking at, so we have a total of 3X2X3 or 18 different samples we want to measure. We decide to replicate wild type at 0 minutes in each 10plex for our total 20 wells accross the 2 10-plexes.\nOur collaborator has alerted us that there may have been a label swap in the dataset. We need to see if we can find two samples which seem to have been swapped, and correct the error if we feel confident that we know what swap took place.\nNote: This data has been adapted with permission from an unpublished study. The biological context of the original data has been changed, and all gene names were shuffled."
  },
  {
    "objectID": "session3/pSet3.html#loading-data",
    "href": "session3/pSet3.html#loading-data",
    "title": "20  Problem Set 3",
    "section": "20.3 Loading Data",
    "text": "20.3 Loading Data\nLoad in the data phospho_exp2_safe.csv and phospho_exp2_safe.csv.\nThere are two variables of interest, the time, 0, 5, or 60 minutes post-infection, and the genotype, WT, NPC1 knockout and RAB7A knockout.\nUnfortunately, all of this data is embedded in the column names of the dataset.\nCreate a metadata_plex# dataframes to contain this data instead. You can try to do this programatically from the column names, or you can type out the data manually."
  },
  {
    "objectID": "session3/pSet3.html#pca",
    "href": "session3/pSet3.html#pca",
    "title": "20  Problem Set 3",
    "section": "20.4 PCA",
    "text": "20.4 PCA\nAs an initial quality check, let’s run PCA on our data. We can use prcomp to run pca, and autoplot to plot the result. Let’s try making 2 pca plots, 1 for each 10plex. We can set the color equal to the genotype and the shape of the points equal to the time.\nYou can call prcomp and autoplot like this:\nlibrary(ggfortify)\n#PCA Plots\npca_res2 <- prcomp(plex2_data, scale = FALSE)\nautoplot(pca_res2, data=metadata_plex2, color = 'condition', shape='time', size=3)\nHint: prcomp might be expecting data in a wide format as opposed to a long format, meaning that we need to make each peptide a column and each row a sample. We can use the t() function and convert the result to a dataframe to get our data into this format.\nNote: You may need to set the scale parameter to FALSE to avoid an error in prcomp.\nWe should look at how our replicates are clustered. Does everything look good in both 10-plexes?"
  },
  {
    "objectID": "session3/pSet3.html#heatmaps",
    "href": "session3/pSet3.html#heatmaps",
    "title": "20  Problem Set 3",
    "section": "20.5 Heatmaps",
    "text": "20.5 Heatmaps\nLet’s explore this more by looking at some heatmaps of our data. We can use the heatmap function to plot a heatmap of the correlation between each of the samples in each 10plex.\nBelow is how to calculate the correlation and call the heatmap function. You can try to use the RowSideColors argument or change the column names to improve the visualization.\nheatmap(x=cor(plex2_data))\n*Hint: heatmap only accepts numeric columns.`\nIs there anything unexpected in how the samples have clustered here?"
  },
  {
    "objectID": "session3/pSet3.html#resolving-the-issue",
    "href": "session3/pSet3.html#resolving-the-issue",
    "title": "20  Problem Set 3",
    "section": "20.6 Resolving the issue",
    "text": "20.6 Resolving the issue\nDecide what to do about the potential label swap and explain your reasoning. You could declare there to be too much uncertainty and report to your collaborator that they will have to redo the experiment, decide there is no label swap, or correct a label swap and continue the analysis.\nDo you feel confident enough to continue the analysis, or is there too much uncertainty to use this data? What other factors might influence your decision?\nIf there is additional analysis you want to perform or calculations you want to make to support your answer, feel free to do so. If you are unsure how to perform that analysis or it would be outside the scope of a problem set, instead describe what you would do and how you would use the results."
  },
  {
    "objectID": "session3/tidyverse.html",
    "href": "session3/tidyverse.html",
    "title": "19  Tidyverse",
    "section": "",
    "text": "20 Data Wrangling with Tidyverse\nThe Tidyverse suite of integrated packages are designed to work together to make common data science operations more user friendly. The packages have functions for data wrangling, tidying, reading/writing, parsing, and visualizing, among others. There is a freely available book, R for Data Science, with detailed descriptions and practical examples of the tools available and how they work together. We will explore the basic syntax for working with these packages, as well as, specific functions for data wrangling with the ‘dplyr’ package and data visualization with the ‘ggplot2’ package."
  },
  {
    "objectID": "session3/tidyverse.html#tidyverse-basics",
    "href": "session3/tidyverse.html#tidyverse-basics",
    "title": "19  Tidyverse",
    "section": "20.1 Tidyverse basics",
    "text": "20.1 Tidyverse basics\nThe Tidyverse suite of packages introduces users to a set of data structures, functions and operators to make working with data more intuitive, but is slightly different from the way we do things in base R. Two important new concepts we will focus on are pipes and tibbles.\nBefore we get started with pipes or tibbles, let’s load the library:\n\nlibrary(tidyverse)\n\n\n20.1.1 Pipes\nStringing together commands in R can be quite daunting. Also, trying to understand code that has many nested functions can be confusing.\nTo make R code more human readable, the Tidyverse tools use the pipe, %>%, which was acquired from the magrittr package and is now part of the dplyr package that is installed automatically with Tidyverse. The pipe allows the output of a previous command to be used as input to another command instead of using nested functions.\n\nNOTE: Shortcut to write the pipe is shift + command + M\n\nAn example of using the pipe to run multiple commands:\n\n## A single command\nsqrt(83)\n\n[1] 9.110434\n\n## Base R method of running more than one command\nround(sqrt(83), digits = 2)\n\n[1] 9.11\n\n## Running more than one command with piping\nsqrt(83) %>% round(digits = 2)\n\n[1] 9.11\n\n\nThe pipe represents a much easier way of writing and deciphering R code, and so we will be taking advantage of it, when possible, as we work through the remaining lesson.\n\n\n20.1.2 Tibbles\nA core component of the tidyverse is the tibble. Tibbles are a modern rework of the standard data.frame, with some internal improvements to make code more reliable. They are data frames, but do not follow all of the same rules. For example, tibbles can have numbers/symbols for column names, which is not normally allowed in base R.\nImportant: tidyverse is very opininated about row names. These packages insist that all column data (e.g. data.frame) be treated equally, and that special designation of a column as rownames should be deprecated. Tibble provides simple utility functions to handle rownames: rownames_to_column() and column_to_rownames().\nTibbles can be created directly using the tibble() function or data frames can be converted into tibbles using as_tibble(name_of_df).\n\nNOTE: The function as_tibble() will ignore row names, so if a column representing the row names is needed, then the function rownames_to_column(name_of_df) should be run prior to turning the data.frame into a tibble. Also, as_tibble() will not coerce character vectors to factors by default."
  },
  {
    "objectID": "session3/tidyverse.html#experimental-data",
    "href": "session3/tidyverse.html#experimental-data",
    "title": "19  Tidyverse",
    "section": "20.2 Experimental data",
    "text": "20.2 Experimental data\nWe’re going to explore the Tidyverse suite of tools to wrangle our data to prepare it for visualization. Make sure you have the file called gprofiler_results_Mov10oe.tsv.\nThe dataset:\n\nRepresents the functional analysis results, including the biological processes, functions, pathways, or conditions that are over-represented in a given list of genes.\nOur gene list was generated by differential gene expression analysis and the genes represent differences between control mice and mice over-expressing a gene involved in RNA splicing.\n\nThe functional analysis that we will focus on involves gene ontology (GO) terms, which:\n\ndescribe the roles of genes and gene products\norganized into three controlled vocabularies/ontologies (domains):\n\nbiological processes (BP)\ncellular components (CC)\nmolecular functions (MF)"
  },
  {
    "objectID": "session3/tidyverse.html#analysis-goal-and-workflow",
    "href": "session3/tidyverse.html#analysis-goal-and-workflow",
    "title": "19  Tidyverse",
    "section": "20.3 Analysis goal and workflow",
    "text": "20.3 Analysis goal and workflow\nGoal: Visually compare the most significant biological processes (BP) based on the number of associated differentially expressed genes (gene ratios) and significance values by creating the following plot:\n\n\n\ndotplot6\n\n\nTo wrangle our data in preparation for the plotting, we are going to use the Tidyverse suite of tools to wrangle and visualize our data through several steps:\n\nRead in the functional analysis results\nExtract only the GO biological processes (BP) of interest\nSelect only the columns needed for visualization\nOrder by significance (p-adjusted values)\nRename columns to be more intuitive\nCreate additional metrics for plotting (e.g. gene ratios)\nPlot results"
  },
  {
    "objectID": "session3/tidyverse.html#instructions",
    "href": "session3/tidyverse.html#instructions",
    "title": "19  Tidyverse",
    "section": "20.4 Instructions",
    "text": "20.4 Instructions\nFind a partner (or a group of 3 if needed). Choose one person to go through the following steps using Tidyverse, and the other using base R. It is recommended that the person with more experience attempt the steps in base R."
  },
  {
    "objectID": "session3/tidyverse.html#tidyverse-tools",
    "href": "session3/tidyverse.html#tidyverse-tools",
    "title": "19  Tidyverse",
    "section": "20.5 Tidyverse tools",
    "text": "20.5 Tidyverse tools\nWhile all of the tools in the Tidyverse suite are deserving of being explored in more depth, we are going to investigate more deeply the reading (readr), wrangling (dplyr), and plotting (ggplot2) tools."
  },
  {
    "objectID": "session3/tidyverse.html#read-in-the-functional-analysis-results",
    "href": "session3/tidyverse.html#read-in-the-functional-analysis-results",
    "title": "19  Tidyverse",
    "section": "20.6 1. Read in the functional analysis results",
    "text": "20.6 1. Read in the functional analysis results\n\nTidyverseBase R\n\n\nWhile the base R packages have perfectly fine methods for reading in data, the readr and readxl Tidyverse packages offer additional methods for reading in data. Let’s read in our tab-delimited functional analysis results gprofiler_results_Mov10oe.tsv using read_delim(). Name the dataframe functional_GO_results.\n\n\nUse one of the base R read.X functions to read in the tab delimited file gprofiler_results_Mov10oe.tsv. Name the dataframe functional_GO_results.\n\n\n\nDouble check the data types and format of your dataframe. Do the methods yield the same result? Convert anything you think should be a factor into a factor.\nNOTE: A large number of tidyverse functions will work with both tibbles and dataframes, and the data structure of the output will be identical to the input. However, there are some functions that will return a tibble (without row names), whether or not a tibble or dataframe is provided."
  },
  {
    "objectID": "session3/tidyverse.html#extract-only-the-go-biological-processes-bp-of-interest",
    "href": "session3/tidyverse.html#extract-only-the-go-biological-processes-bp-of-interest",
    "title": "19  Tidyverse",
    "section": "20.7 2. Extract only the GO biological processes (BP) of interest",
    "text": "20.7 2. Extract only the GO biological processes (BP) of interest\nNow that we have our data, we will need to wrangle it into a format ready for plotting. To extract the biological processes of interest, we only want those rows where the domain is equal to BP.\n\nTidyverseBase R\n\n\nFor all of our data wrangling steps we will be using tools from the dplyr package, which is a swiss-army knife for data wrangling of data frames.\nTo extract the biological processes of interest, we only want those rows where the domain is equal to BP, which we can do using the filter() function.\nTo filter rows of a data frame/tibble based on values in different columns, we give a logical expression as input to the filter() function to return those rows for which the expression is TRUE.\nPerform an additional filtering step to only keep those rows where the relative.depth is greater than 4.\n\n\nUse a conditional expression and indexing ([]) to extract the rows where the domain is equal to BP.\nPerform an additional indexing step to only keep those rows where the relative.depth is greater than 4.\n\n\n\nNow we have returned only those rows with a domain of BP. How have the dimensions of our results changed?"
  },
  {
    "objectID": "session3/tidyverse.html#select-only-the-columns-needed-for-visualization",
    "href": "session3/tidyverse.html#select-only-the-columns-needed-for-visualization",
    "title": "19  Tidyverse",
    "section": "20.8 3. Select only the columns needed for visualization",
    "text": "20.8 3. Select only the columns needed for visualization\nFor visualization purposes, we are only interested in the columns related to the GO terms, the significance of the terms, and information about the number of genes associated with the terms.\n\nTidyverseBase R\n\n\nTo extract columns from a data frame/tibble we can use the select() function. In contrast to base R, we do not need to put the column names in quotes for selection.\nSelect the columns term.id, term.name, p.value, query.size, term.size, overlap.size, intersection.\n\n\nIndex the columnsterm.id, term.name, p.value, query.size, term.size, overlap.size, intersection.\n\n\n\nBoth indesing and the select() function also allows for negative selection. However, select allows for negtaive selection using column names, while in base R we can only do so with indexes. Note that we need to put the column names inside of the combine (c()) function with a - preceding it for this functionality.\nTo use column names in base R, we have to use %in%:\n# Selecting columns to keep\nidx <- !(colnames(functional_GO_results) %in% c(\"query.number\", \"significant\", \"recall\", \"precision\", \"subgraph.number\", \"relative.depth\", \"domain\"))"
  },
  {
    "objectID": "session3/tidyverse.html#order-go-processes-by-significance-adjusted-p-values",
    "href": "session3/tidyverse.html#order-go-processes-by-significance-adjusted-p-values",
    "title": "19  Tidyverse",
    "section": "20.9 4. Order GO processes by significance (adjusted p-values)",
    "text": "20.9 4. Order GO processes by significance (adjusted p-values)\nNow that we have only the rows and columns of interest, let’s arrange these by significance, which is denoted by the adjusted p-value.\n\nTidyverseBase R\n\n\nSort the rows by adjusted p-value with the arrange() function.\n\n\nSort the rows by adjusted p-value with the order() function.\n\n\n\nNOTE: If you wanted to arrange in descending order, then you could have run the following instead:\n# Order by adjusted p-value descending\nfunctional_GO_results <- functional_GO_results %>%\narrange(desc(p.value))\nNOTE: Ordering variables in ggplot2 is a bit different. This post introduces a few ways of ordering variables in a plot."
  },
  {
    "objectID": "session3/tidyverse.html#rename-columns-to-be-more-intuitive",
    "href": "session3/tidyverse.html#rename-columns-to-be-more-intuitive",
    "title": "19  Tidyverse",
    "section": "20.10 5. Rename columns to be more intuitive",
    "text": "20.10 5. Rename columns to be more intuitive\nWhile not necessary for our visualization, renaming columns more intuitively can help with our understanding of the data. Let’s rename the term.id and term.name columns.\n\nTidyverseBase R\n\n\nRename term.id and term.name to GO_id and GO_term using the rename function. Note that you may need to call rename as dplyr::rename, since rename is a common function name in other packages.\nThe syntax is new_name = old_name.\n\n\nRename term.id and term.name to GO_id and GO_term using colnames and indexing."
  },
  {
    "objectID": "session3/tidyverse.html#create-additional-metrics-for-plotting-e.g.-gene-ratios",
    "href": "session3/tidyverse.html#create-additional-metrics-for-plotting-e.g.-gene-ratios",
    "title": "19  Tidyverse",
    "section": "20.11 6. Create additional metrics for plotting (e.g. gene ratios)",
    "text": "20.11 6. Create additional metrics for plotting (e.g. gene ratios)\nFinally, before we plot our data, we need to create a couple of additional metrics. Let’s generate gene ratios to reflect the number of DE genes associated with each GO process relative to the total number of DE genes.\nThis is calculated as gene_ratio = overlap.size / query.size.\n\nTidyverseBase R\n\n\nThe mutate() function enables you to create a new column from an existing column.\n\n\nCreate a new column in the dataframe using the $ syntax or cbind.\n\n\n\nThe mutate() function enables you to create a new column from an existing column."
  },
  {
    "objectID": "session3/tidyverse.html#compare-code",
    "href": "session3/tidyverse.html#compare-code",
    "title": "19  Tidyverse",
    "section": "20.12 Compare code",
    "text": "20.12 Compare code\nTake a look at your code verses your partner’s code. Which method do you think results in cleaner, more readable code? Which steps were easier in base R, and which in Tidyverse?\n\n20.12.1 Additional resources\n\nR for Data Science\nteach the tidyverse\ntidy style guide\n\n\nThe materials in this lesson have been adapted from work created by the (HBC)](http://bioinformatics.sph.harvard.edu/) and Data Carpentry (http://datacarpentry.org/). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  }
]