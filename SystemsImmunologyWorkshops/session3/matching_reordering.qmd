# Matching and Reordering Data in R

## Logical operators for identifying matching elements

Oftentimes, we encounter different analysis tools that require multiple input datasets. It is not uncommon for these inputs to need to have the same row names, column names, or unique identifiers in the same order to perform the analysis. Therefore, knowing how to reorder datasets and determine whether the data matches is an important skill.

In our use case, we will be working with genomic data. We have gene expression data generated by RNA-seq; in addition, we have a metadata file corresponding to the RNA-seq samples. The metadata contains information about the samples present in the gene expression file, such as which sample group each sample belongs to and any batch or experimental variables present in the data.

Let's read in some gene expression data (RPKM matrix):

```{r}
rpkm_data <- read.csv("../data/counts.rpkm")
metadata <- read.csv(file="../data/mouse_exp_design.csv")
```

> **NOTE:** If the data file name ends with `txt` instead of `csv`, you can read in the data using the code: `rpkm_data <- read.csv("../data/counts.rpkm.txt")`.

Take a look at the first few lines of the data matrix to see what's in there.

```{r}
head(rpkm_data)
```

It looks as if the sample names (header) in our data matrix are similar to the row names of our metadata file, but it's hard to tell since they are not in the same order. We can do a quick check of the number of columns in the count data and the rows in the metadata and at least see if the numbers match up.

```{r}
ncol(rpkm_data)
nrow(metadata)
```

What we want to know is, **do we have data for every sample that we have metadata?**

## The `%in%` operator

Although lacking in [documentation](http://dr-k-lo.blogspot.com/2013/11/), this operator is well-used and convenient once you get the hang of it. The operator is used with the following syntax:

``` r
vector1 %in% vector2
```

It will take each element from vector1 as input, one at a time, and **evaluate if the element is present in vector2.** *The two vectors do not have to be the same size.* This operation will return a vector containing logical values to indicate whether or not there is a match. The new vector will be of the same length as vector1. Take a look at the example below:

```{r}
A <- c(1,3,5,7,9,11)   # odd numbers
B <- c(2,4,6,8,10,12)  # even numbers

# test to see if each of the elements of A is in B	
A %in% B
```

Since vector A contains only odd numbers and vector B contains only even numbers, the operation returns a logical vector containing six `FALSE`, suggesting that no element in vector A is present in vector B. Let's change a couple of numbers inside vector B to match vector A:

```{r}
A <- c(1,3,5,7,9,11)   # odd numbers
B <- c(2,4,6,8,1,5)  # add some odd numbers in 
```

```{r}
# test to see if each of the elements of A is in B
A %in% B
```

The returned logical vector denotes which elements in `A` are also in `B` - the first and third elements, which are 1 and 5.

We saw previously that we could use the output from a logical expression to subset data by returning only the values corresponding to `TRUE`. Therefore, we can use the output logical vector to subset our data, and return only those elements in `A`, which are also in `B` by returning only the TRUE values:

![matching1](../img/in-operator1.png)

```{r}
intersection <- A %in% B
intersection
```

![matching2](../img/in-operator2.png)

```{r}
A[intersection]
```

![matching3](../img/in-operator3.png)

In these previous examples, the vectors were so small that it's easy to check every logical value by eye; but this is not practical when we work with large datasets (e.g. a vector with 1000 logical values). Instead, we can use `any` function. Given a logical vector, this function will tell you whether **at least one value** is `TRUE`. It provides us a quick way to assess if **any of the values contained in vector A are also in vector B**:

```{r}
any(A %in% B)
```

The `all` function is also useful. Given a logical vector, it will tell you whether **all values** are `TRUE`. If there is at least one `FALSE` value, the `all` function will return a `FALSE`. We can use this function to assess whether **all elements from vector A are contained in vector B**.

```{r}
all(A %in% B)
```

Suppose we had two vectors containing same values. How can we check **if those values are in the same order in each vector**? In this case, we can use `==` operator to compare each element of the same position from two vectors. The operator returns a logical vector indicating TRUE/FALSE at each position. Then we can use `all()` function to check if all values in the returned vector are TRUE. If all values are TRUE, we know that these two vectors are the same. Unlike `%in%` operator, `==` operator requires that **two vectors are of equal length**.

```{r}
A <- c(10,20,30,40,50)
B <- c(50,40,30,20,10)  # same numbers but backwards 

# test to see if each element of A is in B
A %in% B

# test to see if each element of A is in the same position in B
A == B

# use all() to check if they are a perfect match
all(A == B)

```

Let's try this on our genomic data, and see whether we have metadata information for all samples in our expression data. We'll start by creating two vectors: one is the `rownames` of the metadata, and one is the `colnames` of the RPKM data. These are base functions in R which allow you to extract the row and column names as a vector:

```{r}
x <- rownames(metadata)
y <- colnames(rpkm_data)
```

Now check to see that all of `x` are in `y`:

```{r}
all(x %in% y)
```

*Note that we can use nested functions in place of `x` and `y` and still get the same result:*

```{r}
all(rownames(metadata) %in% colnames(rpkm_data))
```

We know that all samples are present, but are they in the same order?

```{r}
x == y
all(x == y)
```

**Exercise**

::: {.callout-note appearance="simple" icon="false"}
## Basic

We have a list of 6 marker genes that we are very interested in. Our goal is to extract count data for these genes using the `%in%` operator from the `rpkm_data` data frame, instead of scrolling through `rpkm_data` and finding them manually.

First, let's create a vector called `important_genes` with the Ensembl IDs of the 6 genes we are interested in:

```{r}
important_genes <- c("ENSMUSG00000083700", "ENSMUSG00000080990", "ENSMUSG00000065619", "ENSMUSG00000047945", "ENSMUSG00000081010", "ENSMUSG00000030970")
```

1.  Use the `%in%` operator to determine if all of these genes are present in the row names of the `rpkm_data` dataframe.

2.  Extract the rows from `rpkm_data` that correspond to these 6 genes using `[]` and the `%in%` operator. Double check the row names to ensure that you are extracting the correct rows.

3.  Extract the rows from `rpkm_data` that correspond to these 6 genes using `[]`, but without using the `%in%` operator.
:::

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
#1
important_genes %in% rownames(rpkm_data)

#2
idx <- rownames(rpkm_data) %in% important_genes
ans <- rpkm_data[idx, ]
idx2 <- which(rownames(rpkm_data) %in% important_genes)
ans2 <- rpkm_data[idx2, ]

#3.
ans3 <- rpkm_data[important_genes, ]
```
:::

::: {.callout-caution appearance="simple" icon="false"}
## Advanced

Using `important_genes` as defined above, check whether or not the genes which in the `rpkm_data` dataframe are in *the same order* as `important_genes`. Return a vector indicating, for each important gene in `important_genes`, whether or not its order rank is the same as it's order rank in `rpkm_data`, i.e. whether or not the second gene in `important_genes` is also the second important gene to appear in `rpkm_data`.
:::

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
#This is actually very simple to do, given the basic solutions
rownames(ans2) == rownames(ans3)
```
:::

::: {.callout-important appearance="simple" icon="false"}
## Challenge

You are already upset with your collaborator for giving you data which uses Ensembl IDs as identifiers (we will convert these IDs soon). They then write down 2 genes of interest for you to look for in the dataset before leaving on vacation.

When you look at the gene list a few days later, you realize you cannot make out some of their handwriting. You decipher what you can, but realize there are some digits you simply cannot interpret.

```{r}
collaborator_genes <- c("ENSMUSG00000081**0", "ENSMUSG00000030*7*")
```

Find all genes in `rpkm_data` which match these two identifiers, where `*` could be replaced with any single 0-9 digit.

*Hint: You'll probably want to use something like [grep](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/grep), which can pattern match based on [regular expressions](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html). You can make sure you have the right regular expression [regular here](https://regexlearn.com/playground?id=63ec345438ebd467bfb0ac1e)*
:::

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
regexes <- c("ENSMUSG00000081\\d\\d0", "ENSMUSG00000030\\d7\\d")
rpkm_data[grep(regexes[1], rownames(rpkm_data)),]
rpkm_data[grep(regexes[2], rownames(rpkm_data)),]

#Another way yo do things using do.call, rbind, and lapply 
get_fuzzygene <- function(x){rpkm_data[grep(x, rownames(rpkm_data)),]}
ans4 <- do.call(rbind, lapply(regexes,get_fuzzygene))
```
:::

## Reordering data using `match`

We can use the `match()` function to match the values in two vectors. We'll be using it to evaluate which values are present in both vectors, and how to reorder the elements to make the values match.

match() takes 2 arguments. The first argument is a vector of values in the order you want, while the second argument is the vector of values to be reordered such that it will match the first:

1.  a vector of values in the order you want
2.  a vector of values to be reordered

The function returns the position of the matches (indices) with respect to the second vector, which can be used to re-order it so that it matches the order in the first vector. Let's use match() on the first and second vectors we created.

```{r}
first <- c("A","B","C","D","E")
second <- c("B","D","E","A","C")  # same letters but different order
match(first,second)
```

The output is the indices for how to reorder the second vector to match the first. *These indices match the indices that we derived manually before.*

Now, we can just use the indices to reorder the elements of the `second` vector to be in the same positions as the matching elements in the `first` vector:

```{r}
# Saving indices for how to reorder `second` to match `first`
reorder_idx <- match(first,second) 
```

Then, we can use those indices to reorder the second vector similar to how we ordered with the manually derived indices.

```{r}
# Reordering the second vector to match the order of the first vector
second[reorder_idx]
```

If the output looks good, we can save the reordered vector to a new variable.

```{r}
# Reordering and saving the output to a variable
second_reordered <- second[reorder_idx]  
```

![matching7](../img/match3-reordered.png)

Now that we know how `match()` works, let's change vector `second` so that only a subset are retained:

```{r}
first <- c("A","B","C","D","E")
second <- c("D","B","A")  # remove values
```

![matching5](../img/match2.png)

And try to `match()` again:

```{r}
match(first,second)
```

We see that the `match()` function takes every element in the first vector and finds the position of that element in the second vector, and if that element is not present, will return a missing value of NA. The value NA represents missing data for any data type within R. In this case, we can see that the `match()` function output represents the value at position 3 as first, which is A, then position 2 is next, which is B, the value coming next is supposed to be C, but it is not present in the `second` vector, so NA is returned, so on and so forth.

> **NOTE:** For values that don't match by default return an `NA` value. You can specify what values you would have it assigned using `nomatch` argument. Also, if there is more than one matching value found only the first is reported.

If we rearrange `second` using these indices, then we should see that all the values present in both vectors are in the same positions and NAs are present for any missing values.

```{r}
second[match(first, second)]
```

### Reordering genomic data using `match()` function

While the input to the `match()` function is always going to be to vectors, often we need to use these vectors to reorder the rows or columns of a data frame to match the rows or columns of another dataframe. Let's explore how to do this with our use case featuring RNA-seq data. To perform differential gene expression analysis, we have a data frame with the expression data or counts for every sample and another data frame with the information about to which condition each sample belongs. For the tools doing the analysis, the samples in the counts data, which are the column names, need to be the same and in the same order as the samples in the metadata data frame, which are the rownames.

We can take a look at these samples in each dataset by using the `rownames()` and `colnames()` functions.

```{r}
# Check row names of the metadata
rownames(metadata)

# Check the column names of the counts data
colnames(rpkm_data)
```

We see the row names of the metadata are in a nice order starting at `sample1` and ending at `sample12`, while the column names of the counts data look to be the same samples, but are randomly ordered. Therefore, we want to reorder the columns of the counts data to match the order of the row names of the metadata. To do so, we will use the `match()` function to match the row names of our metadata with the column names of our counts data, so these will be the arguments for match.

To do so, we will use the match function to match the row names of our metadata with the column names of our counts data, so these will be the arguments for `match()`.

Within the `match()` function, the rownames of the metadata is the vector in the order that we want, so this will be the first argument, while the column names of the count or rpkm data is the vector to be reordered. We will save these indices for how to reorder the column names of the count data such that it matches the rownames of the metadata to a variable called `genomic idx`.

```{r}
genomic_idx <- match(rownames(metadata), colnames(rpkm_data))
genomic_idx
```

The `genomic_idx` represents how to re-order the column names in our counts data to be identical to the row names in metadata.

Now we can create a new counts data frame in which the columns are re-ordered based on the `match()` indices. Remember that to reorder the rows or columns in a data frame we give the name of the data frame followed by square brackets, and then the indices for how to reorder the rows or columns.

Our `genomic_idx` represents how we would need to reorder the **columns** of our count data such that the column names would be in the same order as the row names of our metadata. Therefore, we need to add our `genomic_idx` to the **columns position**. We are going to save the output of the reordering to a new data frame called `rpkm_ordered`.

```{r}
# Reorder the counts data frame to have the sample names in the same order as the metadata data frame
rpkm_ordered  <- rpkm_data[ , genomic_idx]
```

Check and see what happened by clicking on the `rpkm_ordered` in the Environment window or using the `View()` function.

```{r}
# View the reordered counts
View(rpkm_ordered)
```

We can see the sample names are now in a nice order from sample 1 to 12, just like the metadata. One thing to note is that you would never want to rearrange just the column names without the rest of the column because that would dissociate the sample name from it's values.

You can also verify that column names of this new data matrix matches the metadata row names by using the `all` function:

```{r}
all(rownames(metadata) == colnames(rpkm_ordered))
```

Now that our samples are ordered the same in our metadata and counts data, **if these were raw counts (not RPKM)** we could proceed to perform differential expression analysis with this dataset.

------------------------------------------------------------------------

**Exercises: Adding data from biomaRt**

Let's convert these ensembl ID's into gene symbols. There are a number of ways to do this in R, but we will be using the `biomaRt` package. [BiomaRt](https://useast.ensembl.org/info/data/biomart/biomart_r_package.html) lets us easily map a variety of biological identifiers and choose a data source or 'mart'. We can see a list of available dataset.

```{r}
library(biomaRt, quietly = TRUE)
listEnsembl()
# For a reproducible analysis, it's good to always specify versions of databases
ensembl = useEnsembl(biomart="ensembl",version=109)
listDatasets(ensembl)[100:110,]
```

We want to convert ensembl gene ID's into MGI gene symbols. We can use the `getBM` function to get a dataframe of our mapped identifiers.

```{r}
ensembl = useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl")
gene_map <- getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id","mgi_symbol"), values = rownames(rpkm_data), mart=ensembl)
```

::: {.callout-note appearance="simple" icon="false"}
## Basic

1.  Try to replace the current rownames in `rpkm_data` with their mapped gene symbol. You may need to add a new column with the data instead.

2.  Use the `match()` function to subset the `metadata` data frame so that the row names of the `metadata` data frame match the column names of the `subset_rpkm` data frame.
:::

::: {.callout-caution appearance="simple" icon="false"}
## Advanced

We can use the `listAttributes()` and `listFilters()` functions to see what other information we can get using `getBM`. Choose another piece of data to add to `rpkm_data`.
:::

::: {.callout-important appearance="simple" icon="false"}
## Challenge

Use `getBM` to find all genes on chromosomes 2, 6, or 9. Create another dataframe only containing these genes.
:::




------------------------------------------------------------------------

*The materials in this lesson have been adapted from work created by the (HBC)\](http://bioinformatics.sph.harvard.edu/) and Data Carpentry (http://datacarpentry.org/). These are open access materials distributed under the terms of the [Creative Commons Attribution license](https://creativecommons.org/licenses/by/4.0/) (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.*
